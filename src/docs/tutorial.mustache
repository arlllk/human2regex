{{! Copyright (c) 2020 Patrick Demian; Licensed under MIT }}

{{> header}}
		<!-- Main Content -->
		<div class="container contained-container" id="maincontent" role="main">
            <div id="tutorial">
				<h2>Tutorial</h2>
				<br>

				<p class="font-weight-bold">Preface</p>
				<p>Human2Regex (H2R) is a way to spell out a regular expression in an easy to read, easy to modify language. H2R supports multiple languages as well as many (though not all) different regular expression options such as named groups and quantifiers. You may notice multiple keywords specifying the same thing, and that is intended! H2R is made to be flexible and easy to understand. With a range, do you prefer "...", "through", or "to"? It's up to you to choose, H2R supports all of those!</p>

				<p class="font-weight-bold">Your first Match</p>
				<p>Every language starts with a "Hello World" program, so let's match the output of those programs. Matching is done using the keyword "match" followed by what you want to match.
<span class="tutorial-code"><code class="cm-s-idea">
match "Hello World"
</code></span>
				The above statement will generate a regular expression that matches "Hello World". Any invalid characters will automatically be escaped, so you don't need to worry about it. 
				H2R also supports block comments with <code class="cm-s-idea">/**/</code>, or line comments with <code class="cm-s-idea">//</code> or <code class="cm-s-idea">#</code> so you can explain why or what you intend to match.
<span class="tutorial-code"><code class="cm-s-idea">
match "Hello World" // matches the output of "Hello World" programs
</code></span>
				Now what if we want to match every case variation of "Hello World" like "hello world" or "hELLO wORLD"? H2R supports the <code class="cm-s-idea">or</code> operator which allows you to specify many possible combinations.
<span class="tutorial-code"><code class="cm-s-idea">
match "Hello World" or "hello world" or "hELLO wORLD"
</code></span>
				Or, you can use a <code class="cm-s-idea">using</code> statement to specify that you want it to be case insensitive.</p>

				<p class="font-weight-bold">Using Specifiers</p>
				<p>Using statements appear at the beginning. You may have one or more using statements which each can contain one or more specifiers. For example:
<span class="tutorial-code"><code class="cm-s-idea">
using global and case insensitive matching
</code></span>
				or
<span class="tutorial-code"><code class="cm-s-idea">
using global
</code></span>
<span class="tutorial-code"><code class="cm-s-idea">
using case insensitive
</code></span>
				The <code class="cm-s-idea">matching</code> keyword is optional. The flags which are available are:</p>

				<table class="table table-striped table-bordered">
					<thead>
						<tr>
							<th scope="col">Specifier</th>
							<th scope="col">Description</th>
							<th scope="col">Regex flag</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Multiline</td>
							<td>Matches can cross line breaks</td>
							<td>/&lt;your regex&gt;/m</td>
						</tr>
						<tr>
							<td>Global</td>
							<td>Multiple matches are allowed</td>
							<td>/&lt;your regex&gt;/g</td>
						</tr>
						<tr>
							<td>Case Sensitive</td>
							<td>Match must be exact case</td>
							<td><span class="font-italic">none</span></td>
						</tr>
						<tr>
							<td>Case Insensitive</td>
							<td>Match may be any case</td>
							<td>/&lt;your regex&gt;/i</td>
						</tr>
						<tr>
							<td>Exact</td>
							<td>An exact statement matches a whole line exactly, nothing before, nothing after</td>
							<td>/^&lt;your regex&gt;$/</td>
						</tr>
					</tbody>
				</table>

				<p>To match any variation of hello world, we would then do the following:
<span class="tutorial-code"><code class="cm-s-idea">
using case insensitive matching
</code></span>
<span class="tutorial-code"><code class="cm-s-idea">
match "hello world"
</code></span></p>

				<p class="font-weight-bold">Matching multiple items</p>
				<p>H2R comes with 2 options to match multiple items in a row. The first is to simply write multiple seperate <code class="cm-s-idea">match</code> statements like:
<span class="tutorial-code"><code class="cm-s-idea">
match "hello"
</code></span>
<span class="tutorial-code"><code class="cm-s-idea">
match " "
</code></span>
<span class="tutorial-code"><code class="cm-s-idea">
match "world"
</code></span>
				However, you can also use a comma, <code class="cm-s-idea">and</code>, or <code class="cm-s-idea">then</code> for a more concise match. 
<span class="tutorial-code"><code class="cm-s-idea">
match "hello", " ", "world"
</code></span>
				or
<span class="tutorial-code"><code class="cm-s-idea">
match "hello" and " " and "world"
</code></span>
				or
<span class="tutorial-code"><code class="cm-s-idea">
match "hello" then " " then "world"
</code></span>
				or any combination like
<span class="tutorial-code"><code class="cm-s-idea">
match "hello", " " and then "world"
</code></span>

				<p class="font-weight-bold">Optionality</p>
				<p>Sometimes you wish to match something that may or may not exist. In H2R, this is done via the <code class="cm-s-idea">optional</code> or <code class="cm-s-idea">optionally</code> keyword. 
<span class="tutorial-code"><code class="cm-s-idea">
optionally match "hello world"
</code></span>
				will match 0 or 1 "hello world"'s. This can be used along side matching multiple statements in a single <code class="cm-s-idea">match</code> statement.
<span class="tutorial-code"><code class="cm-s-idea">
match "hello", optionally " ", "world"
</code></span>
				will match "hello", an optional space if it exists, and "world". However, the start <code class="cm-s-idea">optional</code> is for the entire match statement. Thus,
<span class="tutorial-code"><code class="cm-s-idea">
optionally match "hello", " ", then "world"
</code></span>
				will actually make the whole "hello world" an optional match rather than just the first "hello". If you want to make the first match optional but keep the rest required, use multiple <code class="cm-s-idea">match</code> statements.</p>

				<p class="font-weight-bold">Negation</p>
				<p>You can negate a match with the operator <code class="cm-s-idea">not</code>
<span class="tutorial-code"><code class="cm-s-idea">
match not "hello world"
</code></span>
				will match everything except for "hello world".</p>

				<p class="font-weight-bold">Other matching specifiers</p>
				<p>Many times you don't know exactly what you wish to match. H2R comes with many specifiers that you can use for your matching. For example, you may wish to match any word. You can do that with:
<span class="tutorial-code"><code class="cm-s-idea">
match a word
</code></span>
				The <code class="cm-s-idea">a</code> or <code class="cm-s-idea">an</code> is optional. The possible specifiers that H2R supports are the following:</p>
				<table class="table table-striped table-bordered">
					<thead>
						<tr>
							<th scope="col">Specifier</th>
							<th scope="col">Description</th>
							<th scope="col">Regex alternative</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Anything</td>
							<td>Matches any character</td>
							<td>.</td>
						</tr>
						<tr>
							<td>Word(s)</td>
							<td>Matches a word</td>
							<td>\w+</td>
						</tr>
						<tr>
							<td>Number(s)</td>
							<td>Matches an integer</td>
							<td>\d+</td>
						</tr>
						<tr>
							<td>Character(s)</td>
							<td>Matches any letter character</td>
							<td>\w</td>
						</tr>
						<tr>
							<td>Digit(s)</td>
							<td>Matches any digit character</td>
							<td>\d</td>
						</tr>
						<tr>
							<td>Whitespace(s)</td>
							<td>Matches any whitespace character</td>
							<td>\s</td>
						</tr>
						<tr>
							<td>Boundary</td>
							<td>Boundary between a word</td>
							<td>\b</td>
						</tr>
						<tr>
							<td>Line Feed</td>
							<td>Matches a newline</td>
							<td>\n</td>
						</tr>
						<tr>
							<td>Newline</td>
							<td>Matches a newline</td>
							<td>\n</td>
						</tr>
						<tr>
							<td>Carriage Return</td>
							<td>Matches a carriage return</td>
							<td>\r</td>
						</tr>
					</tbody>
				</table>

				<p>You can also create ranges of characters to match. Say for example, you wanted to match any characters between a and z, you could write any of the following:
<span class="tutorial-code"><code class="cm-s-idea">
match from "a" to "z" // from is optional
</code></span>
				or
<span class="tutorial-code"><code class="cm-s-idea">
match between "a" and "z" // between is optional
</code></span>
				or
<span class="tutorial-code"><code class="cm-s-idea">
match "a" ... "z" // can use ... or ..
</code></span>
				or
<span class="tutorial-code"><code class="cm-s-idea">
match "a" - "z"
</code></span>
				or
<span class="tutorial-code"><code class="cm-s-idea">
match "a" through "z" // can also use thru
</code></span>

				<p class="font-weight-bold">Repetition</p>
				<!--<p>H2R supports 2 types of repetition: single match repetition, or grouped repetition. When using "match" you can specify the number of captures you want just before the text you want to capture. Example: <code class="cm-s-idea">match 2 digits</code> will match any 2 characters in a row. You can also specify a range you wish to capture. Example: <code class="cm-s-idea">match 2..5 digits</code> will match 2, 3, 4, or 5 digits. You can specify if the final number is exclusive with the "exclusive" keyword. Example: <code class="cm-s-idea">match 2 to 5 exclusive digits</code> will only match up to 4 digits. You can group a repetition using the "repeat" keyword. By default, this will match 0 or more of the following statements. The same qualifiers that exist for match exist for repeat. Example: <code class="cm-s-idea">optionally repeat 3...7 times</code></p>
				
				<p>Optional repeat</p>-->
				<p>TODO</p>
				
				<table class="table table-striped table-bordered">
					<thead>
						<tr>
							<th scope="col">String value</th>
							<th scope="col">Numeric value</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Zero</td><td>0</td>
						</tr>
						<tr>
							<td>One</td><td>1</td>
						</tr>
						<tr>
							<td>Two</td><td>2</td>
						</tr>
						<tr>
							<td>Three</td><td>3</td>
						</tr>
						<tr>
							<td>Four</td><td>4</td>
						</tr>
						<tr>
							<td>Five</td><td>5</td>
						</tr>
						<tr>
							<td>Six</td><td>6</td>
						</tr>
						<tr>
							<td>Seven</td><td>7</td>
						</tr>
						<tr>
							<td>Eight</td><td>8</td>
						</tr>
						<tr>
							<td>Nine</td><td>9</td>
						</tr>
						<tr>
							<td>Ten</td><td>10</td>
						</tr>
					</tbody>
				</table>

				<p class="font-weight-bold">Grouping</p>
				<p>TODO</p>
				<!-- Optional, create a group
				create a group called 
				-->

				<h3>Miscellaneous features</h3>

				<p class="font-weight-bold">Unicode character properties</p>
				<p>You can match specific unicode sequences using <code class="cm-s-idea">"\uXXXX"
				</code> or <code class="cm-s-idea">"\UXXXXXXXX"</code> where X is a hexadecimal character.
<span class="tutorial-code"><code class="cm-s-idea">
match "\u0669" // matches arabic digit 9 "&#x0669;"
</code></span>
				Unicode character classes/scripts can be matched using the <code class="cm-s-idea">unicode</code> keyword.
<span class="tutorial-code"><code class="cm-s-idea">
match unicode "Latin" // matches any latin character
</code></span>
<span class="tutorial-code"><code class="cm-s-idea">
match unicode "N" // matches any number character
</code></span>
				The following Unicode class specifiers are available:</p>
				<table class="table table-striped table-bordered">
					<thead>
						<tr>
							<th scope="col">Class</th>
							<th scope="col">Description</th>
							<th scope="col">Class</th>
							<th scope="col">Description</th>
							<th scope="col">Class</th>
							<th scope="col">Description</th>
							<th scope="col">Class</th>
							<th scope="col">Description</th>
							<th scope="col">Class</th>
							<th scope="col">Description</th>
							<th scope="col">Class</th>
							<th scope="col">Description</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>C</td><td>Other</td>
							<td>Cc</td><td>Control</td>
							<td>Cf</td><td>Format</td>
							<td>Cn</td><td>Unassigned</td>
							<td>Co</td><td>Private use</td>
							<td>Cs</td><td>Surrogate</td>
						</tr>
						<tr>
							<td>L</td><td>Letter</td>
							<td>Ll</td><td>Lower case letter</td>
							<td>Lm</td><td>Modifier letter</td>
							<td>Lo</td><td>Other letter</td>
							<td>Lt</td><td>Title case letter</td>
							<td>Lu</td><td>Upper case letter</td>
						</tr>
						<tr>
							<td>M</td><td>Mark</td>
							<td>Mc</td><td>Spacing mark</td>
							<td>Me</td><td>Enclosing mark</td>
							<td>Mn</td><td>Non-spacing mark</td>
							<td>N</td><td>Number</td>
							<td>Nd</td><td>Decimal number</td>
						</tr>
						<tr>
							<td>Nl</td><td>Letter number</td>
							<td>No</td><td>Other number</td>
							<td>P</td><td>Punctuation</td>
							<td>Pc</td><td>Connector punctuation</td>
							<td>Pd</td><td>Dash punctuation</td>
							<td>Pe</td><td>Close punctuation</td>
						</tr>
						<tr>
							<td>Pf</td><td>Final punctuation</td>
							<td>Pi</td><td>Initial punctuation</td>
							<td>Po</td><td>Other punctuation</td>
							<td>Ps</td><td>Open punctuation</td>
							<td>S</td><td>Symbol</td>
							<td>Sc</td><td>Currency symbol</td>
						</tr>
						<tr>
							<td>Sk</td><td>Modifier symbol</td>
							<td>Sm</td><td>Mathematical symbol</td>
							<td>So</td><td>Other symbol</td>
							<td>Z</td><td>Separator</td>
							<td>Zl</td><td>Line separator</td>
							<td>Zp</td><td>Paragraph separator</td>
						</tr>
						<tr>
							<td>Zs</td><td>Space separator</td>
							<td>&nbsp;</td><td>&nbsp;</td>
							<td>&nbsp;</td><td>&nbsp;</td>
							<td>&nbsp;</td><td>&nbsp;</td>
							<td>&nbsp;</td><td>&nbsp;</td>
							<td>&nbsp;</td><td>&nbsp;</td>
						</tr>
					</tbody>
				</table>

				<p>The following Unicode script specifiers are available:</p>
				<p>Note: Java and .NET require "Is" in front of the script name. For example, "IsLatin" rather than just "Latin"</p>
				<table class="table table-striped table-bordered">
					<tbody>
						<tr>
							<td>Arabic</td>
							<td>Armenian</td>
							<td>Avestan</td>
							<td>Balinese</td>
							<td>Bamum</td>
						</tr>
						<tr>
							<td>Batak</td>
							<td>Bengali</td>
							<td>Bopomofo</td>
							<td>Brahmi</td>
							<td>Braille</td>
						</tr>
						<tr>
							<td>Buginese</td>
							<td>Buhid</td>
							<td>Canadian_Aboriginal</td>
							<td>Carian</td>
							<td>Chakma</td>
						</tr>
						<tr>
							<td>Cham</td>
							<td>Cherokee</td>
							<td>Common</td>
							<td>Coptic</td>
							<td>Cuneiform</td>
						</tr>
						<tr>
							<td>Cypriot</td>
							<td>Cyrillic</td>
							<td>Deseret</td>
							<td>Devanagari</td>
							<td>Egyptian_Hieroglyphs</td>
						</tr>
						<tr>
							<td>Ethiopic</td>
							<td>Georgian</td>
							<td>Glagolitic</td>
							<td>Gothic</td>
							<td>Greek</td>
						</tr>
						<tr>
							<td>Gujarati</td>
							<td>Gurmukhi</td>
							<td>Han</td>
							<td>Hangul</td>
							<td>Hanunoo</td>
						</tr>
						<tr>
							<td>Hebrew</td>
							<td>Hiragana</td>
							<td>Imperial_Aramaic</td>
							<td>Inherited</td>
							<td>Inscriptional_Pahlavi</td>
						</tr>
						<tr>
							<td>Inscriptional_Parthian</td>
							<td>Javanese</td>
							<td>Kaithi</td>
							<td>Kannada</td>
							<td>Katakana</td>
						</tr>
						<tr>
							<td>Kayah_Li</td>
							<td>Kharoshthi</td>
							<td>Khmer</td>
							<td>Lao</td>
							<td>Latin</td>
						</tr>
						<tr>
							<td>Lepcha</td>
							<td>Limbu</td>
							<td>Linear_B</td>
							<td>Lisu</td>
							<td>Lycian</td>
						</tr>
						<tr>
							<td>Lydian</td>
							<td>Malayalam</td>
							<td>Mandaic</td>
							<td>Meetei_Mayek</td>
							<td>Meroitic_Cursive</td>
						</tr>
						<tr>
							<td>Meroitic_Hieroglyphs</td>
							<td>Miao</td>
							<td>Mongolian</td>
							<td>Myanmar</td>
							<td>New_Tai_Lue</td>
						</tr>
						<tr>
							<td>Nko</td>
							<td>Ogham</td>
							<td>Old_Italic</td>
							<td>Old_Persian</td>
							<td>Old_South_Arabian</td>
						</tr>
						<tr>
							<td>Old_Turkic</td>
							<td>Ol_Chiki</td>
							<td>Oriya</td>
							<td>Osmanya</td>
							<td>Phags_Pa</td>
						</tr>
						<tr>
							<td>Phoenician</td>
							<td>Rejang</td>
							<td>Runic</td>
							<td>Samaritan</td>
							<td>Saurashtra</td>
						</tr>
						<tr>
							<td>Sharada</td>
							<td>Shavian</td>
							<td>Sinhala</td>
							<td>Sora_Sompeng</td>
							<td>Sundanese</td>
						</tr>
						<tr>
							<td>Syloti_Nagri</td>
							<td>Syriac</td>
							<td>Tagalog</td>
							<td>Tagbanwa</td>
							<td>Tai_Le</td>
						</tr>
						<tr>
							<td>Tai_Tham</td>
							<td>Tai_Viet</td>
							<td>Takri</td>
							<td>Tamil</td>
							<td>Telugu</td>
						</tr>
						<tr>
							<td>Thaana</td>
							<td>Thai</td>
							<td>Tibetan</td>
							<td>Tifinagh</td>
							<td>Ugaritic</td>
						</tr>
						<tr>
							<td>Vai</td>
							<td>Yi</td>
							<td>&nbsp;</td>
							<td>&nbsp;</td>
							<td>&nbsp;</td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>
{{> footer}}